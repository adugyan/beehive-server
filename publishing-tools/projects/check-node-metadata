#!/usr/bin/env python3
import argparse
import csv
import datetime


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('filenames', nargs='+')
    args = parser.parse_args()

    for filename in args.filenames:
        fieldnames, rows = read_csv_file(filename)

        if not valid_fieldnames(fieldnames):
            print('{} invalid fieldnames'.format(filename))

        for lineno, row in enumerate(rows):
            for error in get_row_errors(row):
                print('{}:{} {}'.format(filename, lineno+2, error))


def read_csv_file(filename):
    with open(filename) as file:
        reader = csv.DictReader(file)
        rows = list(reader)
        fieldnames = reader.fieldnames
        return fieldnames, rows


def valid_fieldnames(fieldnames):
    return fieldnames == [
        'node_id',
        'project_id',
        'vsn',
        'address',
        'lat',
        'lon',
        'description',
        'start_timestamp',
        'end_timestamp',
    ]


def get_row_errors(row):
    if None in row:
        yield 'extra fields'

    if not row['node_id']:
        yield 'no node_id'

    if not row['project_id']:
        yield 'no project_id'

    if not row['vsn']:
        yield 'no vsn'

    if not row['address']:
        yield 'no address'

    if not valid_coordinate(row['lat']):
        yield 'invalid lat'

    if not valid_coordinate(row['lon']):
        yield 'invalid lon'

    if not valid_timestamp(row['start_timestamp']):
        yield 'invalid start_timestamp'

    if row['end_timestamp'] != '' and not valid_timestamp(row['end_timestamp']):
        yield 'invalid end_timestamp'


def valid_coordinate(s):
    try:
        float(s)
        return True
    except ValueError:
        return False


def valid_timestamp(s):
    try:
        datetime.datetime.strptime(s, '%Y/%m/%d %H:%M:%S')
        return True
    except ValueError:
        return False


if __name__ == '__main__':
    main()
