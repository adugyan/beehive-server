#!/usr/bin/env python3
import argparse
from datetime import datetime
import csv
import sys


class Interval:

    def __init__(self, start, end):
        self.start = start
        self.end = end

    def __contains__(self, dt):
        return ((self.start is None or self.start < dt) and
                (self.end is None or dt <= self.end))

    def __repr__(self):
        return repr((self.start, self.end))


def make_interval_list(events):
    intervals = []

    for event in sorted(events, key=lambda e: e['timestamp']):
        if event['event'] in ['commissioned']:
            start = event['timestamp']
            intervals.append(Interval(start, None))

        if event['event'] in ['decommissioned', 'retired']:
            end = event['timestamp']
            if len(intervals) > 0 and intervals[-1].end is None:
                intervals[-1].end = end

    return intervals


def load_nodes_metadata(filename):
    events = []

    with open(filename) as csvfile:
        reader = csv.reader(csvfile)

        for row in reader:
            try:
                lat = float(row[4])
                lon = float(row[5])
            except ValueError:
                continue

            events.append({
                'node_id': row[0],
                'project_id': row[1],
                'vsn': row[2],
                'address': row[3],
                'lat': lat,
                'lon': lon,
                'description': row[6],
            })

    return events


def load_timestamp(timestamp):
    return datetime.strptime(timestamp, '%Y/%m/%d %H:%M:%S')


def load_events_metadata(filename):
    events = []

    with open(filename) as csvfile:
        reader = csv.reader(csvfile)

        for row in reader:
            events.append({
                'node_id': row[0],
                'timestamp': load_timestamp(row[1]),
                'event': row[2],
                'comment': row[3],
            })

    return events


# just build filter instead??? then we can only include things which
# pass other info checks.
def join_metadata(nodes, events):
    nodes_by_id = {node['node_id']: node for node in nodes}

    for node in nodes:
        node['events'] = []

    for event in events:
        try:
            node = nodes_by_id[event['node_id']]
        except KeyError:
            continue

        node['events'].append(event)

    for node in nodes:
        node['commissioned'] = make_interval_list(node['events'])

    return nodes


def read_metadata(basepath):
    nodes = load_nodes_metadata(basepath + '/nodes.csv')
    events = load_events_metadata(basepath + '/events.csv')
    return join_metadata(nodes, events)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('meta', help='metadata config file for view')
    args = parser.parse_args()

    nodes = read_metadata(args.meta)
    nodes_by_id = {node['node_id']: node for node in nodes}

    def isviewable(line):
        fields = line.split(';')
        node_id = fields[0]
        timestamp = load_timestamp(fields[1])

        if node_id not in nodes_by_id:
            return False

        node = nodes_by_id[node_id]

        return any(timestamp in interval for interval in node['commissioned'])

    for line in filter(isviewable, sys.stdin.readlines()):
        sys.stdout.write(line)
