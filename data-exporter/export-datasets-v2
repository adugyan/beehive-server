#!/usr/bin/env python3
import argparse
from cassandra.cluster import Cluster
import configparser
import csv
import datetime
import os
import subprocess
import sys
import waggle.protocol


parser = argparse.ArgumentParser()
parser.add_argument('plugins', nargs='+')
args = parser.parse_args()


executables = {}

for p in (os.path.abspath(p) for p in args.plugins):
    executable = os.path.join(p, 'plugin_bin', 'plugin_beehive')
    if not os.path.exists(executable):
        print(p, 'missing beehive plugin', file=sys.stderr)
        continue

    config = configparser.ConfigParser()
    config.read(os.path.join(p, 'plugin.ver'))
    section = config['plugin']

    plugin = (section['id'], section['version'])
    executables[plugin] = executable

cluster = Cluster()
session = cluster.connect('waggle')

query = 'SELECT plugin_id, plugin_version, data FROM data_messages_v2 WHERE node_id=%s AND date=%s'

results = []
results_by_plugin = {}


writer = csv.writer(sys.stdout)

for r in session.execute(query, ('0000001e0610ef7b', '2018-10-25')):
    plugin = (r.plugin_id, r.plugin_version)

    if plugin not in results_by_plugin:
        results_by_plugin[plugin] = []

    results_by_plugin[plugin].append(r.data)
    results.append(r.data)

for plugin, results in results_by_plugin.items():
    if plugin not in executables:
        print('no plugin for', plugin)
        continue

    input = b''.join(results)
    output = subprocess.check_output([executables[plugin]], input=input)

    for message in waggle.protocol.unpack_messages(output):
        for datagram in waggle.protocol.unpack_datagrams(message['body']):
            for sensorgram in waggle.protocol.unpack_sensorgrams(datagram['body']):
                ts = datetime.datetime.fromtimestamp(sensorgram['timestamp'])
                writer.writerow([
                    ts.strftime('%Y/%m/%d %H:%M:%S'),
                    message['sender_id'],
                    message['sender_sub_id'],
                    sensorgram['sensor_id'],
                    sensorgram['parameter_id'],
                    sensorgram['value'],
                ])
